#include "combsort.h"
#include <QList>

CombSort::CombSort() {
    this->title = "Сортировка расческой";
    this->shortDescription = "Улучшенная по скорости версия сортировки пузырьком.";
    this->description = "Еще одна модификация сортировки пузырьком. Для того, чтобы избавиться от «черепах», будем переставлять элементы, стоящие на расстоянии. Зафиксируем его и будем идти слева направо, сравнивая элементы, стоящие на этом расстоянии, переставляя их, если необходимо. Очевидно, это позволит «черепахам» быстро добраться в начало массива. Оптимально изначально взять расстояние равным длине массива, а далее делить его на некоторый коэффициент, равный примерно 1.247. Когда расстояние станет равно единице, выполняется сортировка пузырьком. В лучшем случае асимптотика равна O(nlogn), в худшем – O(n2). Какая асимптотика в среднем мне не очень понятно, на практике похоже на O(nlogn).";
    this->stepString = "~ O(n*log(n))";
    this->stepValue = "180";

    // шари алгоритма
    this->algoritm.append("1. Выбиратся опорный элемент.");
    this->algoritm.append("2. Производится распределние массива:");
    this->algoritm.append("2.1 Выбираются два индекса l и r в которые заносятся значения левой и правой границ массива.");
    this->algoritm.append("2.2 Индекс l увеличивается пока l-ый элемент н будет больше или равен опорному. ");
    this->algoritm.append("2.3 Индекс r уменьшается пока r-ый элемент не будет меньше или равен опорному.");
    this->algoritm.append("2.4 Если l равен r, то операция распределения закончена. Иначе возвращаемся к шагу 2.2. ");
    this->algoritm.append("3. Рекурсивно упорядочиваются полученные в результате распределения подмассивы. База рекурсии- пустой массив или массив из одного элемента.");

    // код алгоритма
    this->source =
           "double factor = 1.2473309; // фактор уменьшения \n"
           "int step = array.size() - 1; // шаг сортировки \n"

           "//Последняя итерация цикла, когда step==1 эквивалентна одному проходу сортировки пузырьком \n"
           "while (step >= 1) { \n"
           "     for (int i = 0; i + step < array.size(); i++) { \n"
           "         if (array[i] > array[i + step]) { \n"
           "             std::swap(array[i], array[i + step]);\n"
           "         } \n"
           "     } \n"
           "     step /= factor; \n"
           "}";

}



QList<QList<int>> CombSort::sort(QList<int> array) {
    QList<QList<int>> steps;
    steps.append(cloneArray(array));
    double factor = 1.2473309; // фактор уменьшения
    int step = array.size() - 1; // шаг сортировки

    //Последняя итерация цикла, когда step==1 эквивалентна одному проходу сортировки пузырьком
    while (step >= 1) {
        for (int i = 0; i + step < array.size(); i++) {
            if (array[i] > array[i + step]) {
                std::swap(array[i], array[i + step]);
            }
            steps.append(cloneArray(array));
        }
        step /= factor;
    }
    return steps;
}
