#include "combsort.h"
#include <QList>

CombSort::CombSort() {
    this->title = "Сортировка расческой";
    this->shortDescription = "Улучшенная по скорости версия сортировки пузырьком.";
    this->description = "Еще одна модификация сортировки пузырьком. Для того, чтобы избавиться от «черепах», будем переставлять элементы, стоящие на расстоянии. Зафиксируем его и будем идти слева направо, сравнивая элементы, стоящие на этом расстоянии, переставляя их, если необходимо. Очевидно, это позволит «черепахам» быстро добраться в начало массива. Оптимально изначально взять расстояние равным длине массива, а далее делить его на некоторый коэффициент, равный примерно 1.247. Когда расстояние станет равно единице, выполняется сортировка пузырьком. В лучшем случае асимптотика равна O(nlogn), в худшем – O(n2). Какая асимптотика в среднем мне не очень понятно, на практике похоже на O(nlogn).";
    this->stepString = "~ O(n*log(n))";
    this->stepValue = "180";
}



QList<QList<int>> CombSort::sort(QList<int> array) {
    QList<QList<int>> steps;
    steps.append(cloneArray(array));
    double factor = 1.2473309; // фактор уменьшения
    int step = array.size() - 1; // шаг сортировки

    //Последняя итерация цикла, когда step==1 эквивалентна одному проходу сортировки пузырьком
    while (step >= 1) {
        for (int i = 0; i + step < array.size(); i++) {
            if (array[i] > array[i + step]) {
                std::swap(array[i], array[i + step]);
            }
            steps.append(cloneArray(array));
        }
        step /= factor;
    }
    return steps;
}
