#include "bubblesort.h"
#include <QList>

BubbleSort::BubbleSort() {
    // описание алгоритма
    this->title = "Сортировка пузырьком";
    this->shortDescription = "Самая обычная сортировка пузырьком, которой учат в школе.";
    this->description = "Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. Заметим, что после первой итерации самый большой элемент будет находиться в конце массива, на правильном месте. После двух итераций на правильном месте будут стоять два наибольших элемента, и так далее. Очевидно, не более чем после n итераций массив будет отсортирован. Таким образом, асимптотика в худшем и среднем случае – O(n2), в лучшем случае – O(n).";
    this->stepString = "O(n^2)";
    this->stepValue = "400"; // просто считаем эту фигню для 20 элементов. n^2 -> 20x20 = 400

    // шари алгоритма
    this->algoritm.append("Цикл стартует не с нулевого, а первого элемента массива (см. граничные условия). В зависимости от того, как проходит сравнение двух элементов мы либо меняем их местами и отходим на шаг назад, либо не меняем и шагаем на шаг вперед. Особенность этого алгоритма заключается в том, что нам здесь не потребуются вложенные циклы, как, например, в пузырьковой сортировке");


    // код алгоритма
    this->source =
            "for (int i = 0; i < array.size(); i++) {\n"
            "   for (int j = 0; j < array.size() - i - 1; j++) {\n"
            "       if (array[j+1] < array[j]) {\n"
            "           // меняем элементы местами\n"
            "           std::swap(array[j], array[j + 1]);\n"
            "       }\n"
            "   }\n"
            "}";

    // плашки с номинациями в которых этот алгоритм лучший
    this->markers.append(SLOW_MARKER);
    this->markers.append(SIMPLE_MARKER);
}

QList<QList<int>> BubbleSort::sort(QList<int> array) {
    QList<QList<int>> steps;
    // добавляем изначальное значение в шаги
    steps.append(cloneArray(array));
    for (int i = 0; i < array.size(); i++) {
        for (int j = 0; j < array.size() - i - 1; j++) {
            if (array[j+1] < array[j]) {
                std::swap(array[j], array[j + 1]);
            }
            // в конце итерации запоминаем изменения
            steps.append(cloneArray(array));
        }
    }
    return steps;
}
