#include "insertionsort.h"
#include <QList>

InsertionSort::InsertionSort()
{
    // описание алгоритма
    this->title = "Сортировка вставками";
    this->shortDescription = "При сортировке вставками массив постепенно перебирается слева направо. При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.";
    this->description = "Создадим массив, в котором после завершения алгоритма будет лежать ответ. Будем поочередно вставлять элементы из исходного массива так, чтобы элементы в массиве-ответе всегда были отсортированы. Асимптотика в среднем и худшем случае – O(n2), в лучшем – O(n). Реализовывать алгоритм удобнее по-другому (создавать новый массив и реально что-то вставлять в него относительно сложно): просто сделаем так, чтобы отсортирован был некоторый префикс исходного массива, вместо вставки будем менять текущий элемент с предыдущим, пока они стоят в неправильном порядке.";


    this->stepString = "O(n^2)";
    this->stepValue = "400"; // просто считаем эту фигню для 20 элементов. n^2 -> 20x20 = 400

    // шари алгоритма
    this->algoritm.append("Второй элемент массива сравнивается с элементами, которые появляются перед ним (в данном случае только первый элемент). Если второй элемент меньше первого элемента, второй элемент вставляется в позицию первого элемента. После первого шага, первые два элемента массива будут отсортированы.");
    this->algoritm.append("Третий элемент массива сравнивается с элементами, которые появляются перед ним (первый и второй элемент). Если третий элемент меньше первого, он вставляется в позицию первого элемента. Если третий элемент больше первого элемента, но меньше второго элемента, он вставляется в позицию второго элемента. Если третий элемент больше, чем оба элемента, он остается в том же положении. После второго шага первые три элемента массива будут отсортированы.");
    this->algoritm.append("Аналогично, четвертый элемент массива сравнивается с элементами, которые появляются перед ним (первый, второй и третий элемент), и применяется та же процедура, и этот элемент вставляется в правильное положение. После третьего шага первые четыре элемента массива будут отсортированы.");


    // код алгоритма
    this->source =
            "for (size_t i = 1; i < array.size(); ++i) {\n"
            "   int x = array[i];\n"
            "   size_t j = i;\n"
            "   while (j > 0 && array[j - 1] > x) {\n"
            "       array[j] = array[j - 1];\n"
            "       --j;\n"
            "   }\n"
            "   array[j] = x;\n"
            "}";

}


QList<QList<int>> InsertionSort::sort(QList<int> array) {
    QList<QList<int>> steps;
    // добавляем изначальное значение в шаги
    steps.append(cloneArray(array));
    for (size_t i = 1; i < array.size(); ++i) {
       int x = array[i];
       size_t j = i;
       while (j > 0 && array[j - 1] > x) {
         array[j] = array[j - 1];
         --j;
         steps.append(cloneArray(array));
       }
       array[j] = x;
       steps.append(cloneArray(array));
     }
    return steps;
}
