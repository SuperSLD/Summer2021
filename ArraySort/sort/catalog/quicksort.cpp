#include "quicksort.h"
#include <QList>
#include <iostream>


QuickSort::QuickSort(){
    // описание алгоритма
    this->title = "Быстрая сортировка";
    this->shortDescription = "Быстрая сортировка представляет собой усовершенствованный метод сортировки, основанный на принципе обмена. Пузырьковая сортировка является самой неэффективной из всех алгоритмов прямой сортировки. Однако усовершенствованный алгоритм является лучшим из известных методом сортировки массивов. Он обладает столь блестящими характеристиками, что его изобретатель Ч. Хоар назвал его быстрой сортировкой.";
    this->description = "Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его обычно называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два шага к подмассивам справа и слева от опорного значения. \n Быструю сортировку изобрели в 1960 году для машинного перевода: тогда словари хранились на магнитных лентах, а сортировка слов обрабатываемого текста позволяла получить переводы за один прогон ленты, без перемотки назад.";
    this->stepString = "O(n log n)";
//    this->stepValue = "26"; // просто считаем эту фигню для 20 элементов. n^log n -> 20^1,3 = 26

    // шари алгоритма
    this->algoritm.append("1. Выбрать элемент из массива. Назовём его опорным.");
    this->algoritm.append("2. Разбиение: перераспределение элементов в массиве таким образом, что элементы, меньшие опорного, помещаются перед ним, а большие или равные - после.");
    this->algoritm.append("3. Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.");


}

QList<QList<int>> QuickSort::sort(QList<int> array) {
    QList<QList<int>> steps;
    // добавляем изначальное значение в шаги
    steps.append(cloneArray(array));
    //Указатели в начало и в конец массива
       int i = 0;
       int j = 20 - 1;

       //Центральный элемент массива
       int mid = array[20 / 2];

       //Делим массив
       do {
           //Пробегаем элементы, ищем те, которые нужно перекинуть в другую часть
           //В левой части массива пропускаем(оставляем на месте) элементы, которые меньше центрального
           while(array[i] < mid) {
               i++;
               steps.append(cloneArray(array));
           }
           //В правой части пропускаем элементы, которые больше центрального
           while(array[j] > mid) {
               j--;
               steps.append(cloneArray(array));
           }

           //Меняем элементы местами
           if (i <= j) {
               int tmp = array[i];
               array[i] = array[j];
               array[j] = tmp;

               i++;
               j--;
               steps.append(cloneArray(array));
           }
       } while (i <= j);
         steps.append(cloneArray(array));


       //Рекурсивные вызовы, если осталось, что сортировать
       if(j > 0) {
           //"Левый кусок"
           Recurse(array, j + 1);
           steps.append(cloneArray(array));
       }
       if (i < 20) {
           //"Правый кусок"
           Recurse(&array[i], 20 - i);
           steps.append(cloneArray(array));
       }
       return steps;
   }
